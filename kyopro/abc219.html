<!DOCTYPE html>

<html lang="ja">

<head>
	<meta charset="UTF-8">
	<title>ABC219参戦記</title>
	<link rel="icon" href="https://zobio.github.io/test.ico">
</head>

<header>
	<a href="https://zobio.github.io"> <img src="https://zobio.github.io/logo.jpg" width="20%" height="20%"> </a>
</header>

<style>
	.main img{
		width : 40%;
		height : 40%;
	}
</style>

<body>
	<div class="title">
		<h3>2021/9/18</h3>
		<h1>ABC219参戦記</h1>
	</div>
	<hr>
	<div class="main">
		<p>
			ABC219でした。ここ最近調子が良いのですが、先週のABCから情報オリンピックの過去問以外全く問題をといていなかったので少しレートが落ちそうで怖かったです。
		</p>
		<img src="picture/abc219_graph.jpg">
		<p>
			結果は99分4AC4ペナでした。まじで危なかった...
		</p>
		<img src="picture/abc219_result.jpg">
		<p>
			Cがわけわからなすぎていったん飛ばしてD問題を解けたのが終了13分前だったので、もうちょっと時間が少なかったら2完だったかもしれないと思うとまじでホラー映画級に怖いです。
		</p>
		<br>
		<h1>A - AtCoder Quiz 2</h1>
		<p>
			条件分岐で解きます。
		</p>
		<img src="picture/abc219a.jpg">
		<br>
		<h1>B - Maritozzo</h1>
		<p>
			s1, s2, s3をまとめて1つの配列に入れて扱います。<br>
			Tを数値として受け取って% 10と/ 10を繰り返していく方法もありますが、僕は文字列として扱う書き方の方をよく使う気がします。
		</p>
		<img src="picture/abc219b.jpg">
		<br>
		<h1>C - Neo-lexicographic Ordering</h1>
		<p>
			この問題は大きく分けて2つの解法があると思います。
		</p>
		<p>
			1つは自分で比較関数を実装してそれをもとにsortして出力する解法、もう1つは文字列Xを元に新しい文字列の配列を作り、それを元にsortしていくという解法です。
		</p>
		<p>
			僕は後者の方を選びました。
		</p>
		<p>
			vector&lt;pair&lt;string, string&gt;&gt;の各要素について、second要素に元の文字列、first要素に新しい文字列を作り、sortして<span style="color:red"second要素></span>を出力するというのが大まかな流れです。
		</p>
		<p>
			新しい文字列を作る方法は以下の通りです。
		</p>
		<p>
			mapあたりで古いアルファベットのk番目と新しいアルファベットのk番目(1 &lt;= k &lt;= 26)を対応させたものを予め保存しておく
		</p>
		<p>↓</p>
		<p>
			新しい文字列.push_back(map[古い文字列のi番目])という操作を全ての要素について行う。
		</p>
		<p>
			ここで1つ注意が必要で、まあ僕みたいな<span style="color: brown;">アンポンタン</span>以外大丈夫だと思うんですけど、文字の対応は
		</p>
		<p>
			map[元のk番目の文字] = map[新しいk番目の文字]
		</p>
		<p>
			であって、決して
		</p>
		<p>
			map[新しいk番目の文字] = map[元のk番目の文字]
		</p>
		<p>
			じゃないですからね。(ここ間違えてずっと悩んでいたなんて言えない)
		</p>
		<p>
			計算量はO(N * max|Si|)(新しい文字列を作る操作)とO(NlogN)(ソート)で、O(NlogN)になると思います。
		</p>
		<img src="picture/abc219c.jpg">
		<p>
			ここで3WAを出してACになったのが終了23秒前でした。草。
		</p>
		<br>
		<h1>D - Strange Lunchbox</h1>
		<p>
			問題を見てかなり早い段階で、<span style="color: red; font-size: 35px;">ナップサックDPジャン！！！</span>と気づけたのですが、実装にめちゃくちゃ時間がかかってしまいました。
		</p>
		<p>
			この問題のキモは3次元DPであることと、<span style="color: red;">たこ焼き・たい焼きがX個・Y個を超えている</span>時も条件を満たすという所です。
		</p>
		<p>
			3次元DPは扱いに気を付ければ大丈夫です。問題なのは後者で、所謂ナップサック問題の解法から少しひねらないとダメで、僕はめちゃくちゃ思いつくまで時間がかかりました。
		</p>
		<p>
			具体的な解法は以下の通りです。
		</p>
		<p>
			dp[i + 1][j][k] : i番目までの弁当で、ちょうどj個のたこ焼きとちょうどk個のたい焼きを手に入れるために買うお弁当の個数の最小値(初期値:INF, 答えはdp[n][x][y])
		</p>
		<p>
			というDPを用意する。dp[*][0][0] = 0;としておく。(たこ焼き、たい焼きがどちらも0個のため弁当を買う必要がない)
		</p>
		<p>
			漸化式は以下のとおりである。0 ~ N - 1, 0 ~ X, 0 ~ Yの3重ループで値を更新していく。
		</p>
		<p>
			dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k]);
		</p>
		<p style="color: blue;">
			dp[i + 1][min(j + a[i], x)][min(k + b[i], y)] = min(dp[i][j][k] + 1, dp[i + 1][min(j + a[i], x)][min(k + b[i], y)]);
		</p>
		<p>
			2つ目の"配るDP"の式がとても重要です。
		</p>
		<p>
			前述の通り、たこ焼き・たい焼きがX個・Y個を超えている時も条件を満たす、つまり例えば5個のたこ焼きがほしい時に6個たこ焼きがあっても条件を満たすので、重さが制限を超えたら値を捨てる(典型的な)ナップサック問題とは違い、値を捨てることができません。(捨てるとWAになります)
		</p>
		<p>
			ここでよく考えると、たこ焼き・たい焼きの合計がX・Y個を超えてしまった場合は超えた分だけたこ焼き・たい焼きを捨ててX・Y個にしてしまえばいいと分かります。食品ロスですね。(<a href="https://atcoder.jp/contests/abc219/editorial/2651">公式解説</a>ではいらない分を青木君に押し付けています)
		</p>
		<p>
			直感で少し分かりにくいかもしれませんが、5個たこ焼きが食べたい時にたこ焼き100個入りの弁当を買っても条件は満たされる、みたいな感じで考えればなんとなく分かるかもしれません。
		</p>
		<p>
			計算量はO(NXY)です。結構ギリギリですね。
		</p>
		<img src="picture/abc219d.jpg">
		<p>
			多分コンテスト中にナップサック系問題を通せたのは初めてだと思うのでめちゃくちゃ嬉しいです。実装出来たこと自体もとても嬉しいですが、短時間で「この問題はナップサックDPだ」と気づけたことが成長を感じられてヨカッタデス。
		</p>
		<br><br>
		<hr>
		<p>
			という訳でABC219でした。
		</p>
		<p>
			次に4完ができたらおそらく入緑できるので、頑張っていきたいです。
		</p>
		<p>
			(次だけでいいから得意なアルゴリズムばっか出てくれ...!)
		</p>
	</div>
	<br><br>
</body>

</html>